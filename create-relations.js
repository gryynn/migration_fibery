#!/usr/bin/env node
/**
 * ========================================================================
 * RELATION BUILDER - D√©tection et cr√©ation automatique des relations
 * ========================================================================
 *
 * GUIDE D'UTILISATION :
 * ====================
 *
 * 1. PR√âREQUIS :
 *    - Avoir ex√©cut√© csv-to-sql-migrator.js avant
 *    - Avoir cr√©√© les tables dans PostgreSQL/Supabase
 *
 * 2. CONFIGURATION :
 *    - V√©rifiez importantDir : chemin vers votre dossier Important
 *    - Ajustez schema : nom du sch√©ma PostgreSQL
 *    - Modifiez ignoreColumns si n√©cessaire
 *
 * 3. EX√âCUTION :
 *    node create-relations.js
 *
 * 4. R√âSULTAT :
 *    - Fichier relations-complete.sql g√©n√©r√©
 *    - Ex√©cutez-le APR√àS migration-complete.sql dans Supabase
 *
 * PRINCIPE DE FONCTIONNEMENT :
 * ===========================
 * 1. Analyse tous les CSV pour d√©tecter les colonnes de relations
 * 2. Devine automatiquement les tables cibles
 * 3. G√©n√®re les tables de jonction (many-to-many)
 * 4. Cr√©e les INSERT pour peupler les relations
 * 5. Ajoute les index pour les performances
 *
 * EXEMPLE DE D√âTECTION :
 * =====================
 * Colonne "PSM-Insights" dans "Actionalisation-Dopa" ‚Üí
 * Table de jonction: actionalisation_dopa_psm_insights
 * Avec cl√©s √©trang√®res vers les deux tables
 */

const fs = require('fs');
const path = require('path');

// ============================================
// CONFIGURATION - √Ä ADAPTER √Ä VOTRE PROJET
// ============================================
const CONFIG = {
  /**
   * üìÅ Chemin vers le dossier "Important" de votre export Fibery
   * ========================================================
   * M√™me chemin que dans csv-to-sql-migrator.js
   */
  importantDir: 'C:\\Users\\marti\\Downloads\\martunvert.fibery.io_20251023104856287\\Important',

  /**
   * üìÑ Fichier SQL de sortie pour les relations
   */
  outputSQL: './relations-complete.sql',

  /**
   * üóÇÔ∏è Nom du sch√©ma PostgreSQL (doit correspondre au migrateur)
   */
  schema: 'psm_root',

  /**
   * üö´ COLONNES √Ä IGNORER (pas des relations)
   * ========================================
   * Ces colonnes ne seront PAS trait√©es comme des relations
   */
  ignoreColumns: [
    // Colonnes syst√®me courantes
    'id', 'public_id', 'name', 'creation_date', 'modification_date',
    'created_by_id', 'created_by_name', 'created_by',

    // Colonnes de donn√©es simples
    'age', 'score', 'date', 'time', 'year', 'month', 'day',
    'count', 'total', 'sum', 'average', 'min', 'max',

    // Colonnes de texte simple
    'description', 'comment', 'note', 'text', 'content', 'body',

    // Ajoutez ici d'autres colonnes qui ne sont pas des relations
    // Ex: 'status', 'priority', 'category', 'tags'
  ],

  /**
   * üîç OPTIONS DE D√âTECTION
   */
  detection: {
    /**
     * Nombre d'√©chantillons pour analyser les types de donn√©es
     */
    sampleSize: 20,

    /**
     * Seuil minimum de virgules pour consid√©rer comme relation
     */
    minCommaRatio: 0.1,

    /**
     * Patterns de noms de colonnes qui indiquent des relations
     */
    relationPatterns: [
      /^[A-Z][a-z]+-[A-Z]/,  // Ex: "PSM-Insights", "Action-Objectif"
      /_id$/,                // Ex: "user_id", "category_id"
      /_ids$/,               // Ex: "tags_ids", "categories_ids"
    ]
  }
};

// ============================================
// FONCTIONS UTILITAIRES
// ============================================

/**
 * üßπ NORMALISATION DES NOMS POUR POSTGRESQL
 * =========================================
 * M√™me fonction que dans csv-to-sql-migrator.js pour coh√©rence
 */
function sanitizeName(name) {
  if (!name) return 'unnamed';

  // √âtape 1: Supprimer les accents (√© ‚Üí e, √† ‚Üí a, etc.)
  let clean = name
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '');

  // √âtape 2: Remplacer les caract√®res sp√©ciaux
  clean = clean.replace(/[''`]/g, '_');  // Apostrophes ‚Üí underscore
  clean = clean.replace(/[\s\-\./]+/g, '_');  // Espaces, tirets, points, slashes

  // √âtape 3: Garder seulement caract√®res alphanum√©riques + underscore
  clean = clean.replace(/[^a-zA-Z0-9_]/g, '');

  // √âtape 4: Minuscules
  clean = clean.toLowerCase();

  // √âtape 5: Nettoyer les underscores
  clean = clean.replace(/_+/g, '_');  // Multiples ‚Üí simple
  clean = clean.replace(/^_+|_+$/g, '');  // D√©but/fin

  // √âtape 6: V√©rifications sp√©ciales
  if (!clean) clean = 'unnamed';  // Si vide
  if (/^[0-9]/.test(clean)) clean = '_' + clean;  // Commence par chiffre

  // √âtape 7: Limite PostgreSQL (63 caract√®res)
  if (clean.length > 63) {
    clean = clean.substring(0, 63);
  }

  return clean;
}

/**
 * üìÑ PARSING CSV POUR L'ANALYSE DES RELATIONS
 * ===========================================
 * M√™me fonction que dans csv-to-sql-migrator.js
 */
function parseCSV(filePath) {
  const content = fs.readFileSync(filePath, 'utf8');
  const lines = content.split('\n').filter(line => line.trim());

  if (lines.length === 0) return { headers: [], rows: [] };

  const headers = parseCSVLine(lines[0]);
  const rows = [];

  for (let i = 1; i < lines.length; i++) {
    const values = parseCSVLine(lines[i]);
    if (values.length === headers.length) {
      const row = {};
      headers.forEach((header, idx) => {
        row[header] = values[idx];
      });
      rows.push(row);
    }
  }

  return { headers, rows };
}

/**
 * üîß PARSING D'UNE LIGNE CSV
 * ==========================
 * M√™me fonction que dans csv-to-sql-migrator.js
 */
function parseCSVLine(line) {
  const values = [];
  let current = '';
  let inQuotes = false;

  for (let i = 0; i < line.length; i++) {
    const char = line[i];
    const nextChar = line[i + 1];

    if (char === '"' && !inQuotes) {
      inQuotes = true;
    } else if (char === '"' && inQuotes && nextChar === '"') {
      current += '"';
      i++; // Sauter le guillemet suivant
    } else if (char === '"' && inQuotes) {
      inQuotes = false;
    } else if (char === ',' && !inQuotes) {
      values.push(current.trim());
      current = '';
    } else {
      current += char;
    }
  }

  values.push(current.trim());
  return values;
}


// ============================================
// D√âTECTION DES RELATIONS
// ============================================

/**
 * üîç D√âTECTION DES COLONNES DE RELATIONS
 * =====================================
 * D√©termine si une colonne contient des relations many-to-many
 *
 * CRIT√àRES DE D√âTECTION :
 * ======================
 * 1. Nom de colonne dans la liste d'ignor√©s ‚Üí NON
 * 2. Contient des virgules (s√©parateur de listes) ‚Üí OUI
 * 3. Pattern de nom type "PSM-Insights" ‚Üí OUI
 * 4. Pattern de nom type "table_id" ou "table_ids" ‚Üí OUI
 *
 * @param {string} columnName - Nom de la colonne √† analyser
 * @param {string[]} sampleValues - √âchantillon de valeurs (20 premi√®res lignes)
 * @returns {boolean} - true si c'est une colonne de relations
 */
function isRelationColumn(columnName, sampleValues) {
  // √âtape 1: Ignorer les colonnes syst√®me et de donn√©es simples
  const lowerName = columnName.toLowerCase();
  if (CONFIG.ignoreColumns.some(ignored => lowerName.includes(ignored))) {
    return false;
  }

  // √âtape 2: Analyser les valeurs - chercher des virgules (s√©parateur de listes)
  const hasCommas = sampleValues.some(v =>
    v && typeof v === 'string' && v.includes(',')
  );

  // √âtape 3: Analyser le nom - patterns qui indiquent des relations
  const looksLikeTableRef = CONFIG.detection.relationPatterns.some(pattern =>
    pattern.test(columnName)
  );

  // √âtape 4: D√©cision finale
  return hasCommas || looksLikeTableRef;
}

/**
 * üéØ D√âVINER LA TABLE CIBLE D'UNE RELATION
 * =======================================
 * Essaie de deviner quelle table PostgreSQL correspond √† une colonne de relation
 *
 * STRAT√âGIE DE RECHERCHE :
 * =======================
 * 1. Nettoyer le nom de la colonne (sanitizeName)
 * 2. Chercher correspondance exacte avec les tables disponibles
 * 3. Chercher correspondance partielle (inclusion mutuelle)
 * 4. Retourner null si aucune correspondance trouv√©e
 *
 * EXEMPLES :
 * ==========
 * "PSM-Insights" ‚Üí "psm_insights"
 * "Actionalisation-objectives" ‚Üí "actionalisation_obje" (si table existe)
 * "user_id" ‚Üí "user" (si table user existe)
 *
 * @param {string} columnName - Nom de la colonne relation
 * @param {string[]} availableTables - Liste des tables PostgreSQL disponibles
 * @returns {string|null} - Nom de la table cible ou null
 */
function guessTargetTable(columnName, availableTables) {
  const cleanName = sanitizeName(columnName);

  // Strat√©gie 1: Correspondance exacte
  if (availableTables.includes(cleanName)) {
    return cleanName;
  }

  // Strat√©gie 2: Correspondance partielle (inclusion)
  for (const table of availableTables) {
    // Si le nom nettoy√© contient le nom de table, ou inversement
    if (cleanName.includes(table) || table.includes(cleanName)) {
      return table;
    }
  }

  // Strat√©gie 3: Supprimer les suffixes courants des relations
  const withoutSuffix = cleanName.replace(/_id[s]?$/, '');
  if (withoutSuffix !== cleanName && availableTables.includes(withoutSuffix)) {
    return withoutSuffix;
  }

  return null;
}

/**
 * ‚úÇÔ∏è PARSING DES LISTES DE RELATIONS
 * ===================================
 * D√©compose une valeur contenant plusieurs √©l√©ments s√©par√©s par des virgules
 *
 * FORMAT ATTENDU :
 * ================
 * "Valeur 1,Valeur 2,Valeur 3" ‚Üí ["Valeur 1", "Valeur 2", "Valeur 3"]
 *
 * NETTOYAGE APPLIQU√â :
 * ====================
 * - Trim des espaces autour de chaque valeur
 * - Filtrage des valeurs vides
 * - Conservation des virgules √† l'int√©rieur des guillemets
 *
 * @param {string} value - Valeur √† parser
 * @returns {string[]} - Tableau des valeurs nettoy√©es
 */
function parseRelationList(value) {
  if (!value || typeof value !== 'string') return [];

  // √âtape 1: S√©parer par virgule
  const parts = value.split(',');

  // √âtape 2: Nettoyer chaque partie
  return parts
    .map(v => v.trim())           // Supprimer espaces
    .filter(v => v && v.length > 0); // Supprimer vides
}

// ============================================
// ANALYSE DES RELATIONS
// ============================================

function analyzeRelations(databases) {
  console.log('\nüîç Analyse des relations Many-to-Many...\n');
  
  const relations = [];
  
  for (const db of databases) {
    console.log(`üìä ${db.name}:`);
    
    for (const header of db.headers) {
      const sampleValues = db.rows.slice(0, 20).map(row => row[header]);
      
      if (isRelationColumn(header, sampleValues)) {
        const targetTable = guessTargetTable(header, databases.map(d => d.sqlName));
        
        if (targetTable) {
          const relation = {
            sourceTable: db.sqlName,
            sourceColumn: sanitizeName(header),
            targetTable: targetTable,
            originalColumn: header,
            sourceDbName: db.name,
            hasData: sampleValues.some(v => v && v.trim())
          };
          
          relations.push(relation);
          console.log(`  ‚úì ${header} ‚Üí ${targetTable}`);
        } else {
          console.log(`  ‚ö†Ô∏è  ${header} (cible inconnue, stock√© en TEXT)`);
        }
      }
    }
  }
  
  console.log(`\n‚úÖ ${relations.length} relations d√©tect√©es\n`);
  return relations;
}

// ============================================
// G√âN√âRATION SQL
// ============================================

function generateJunctionTables(relations) {
  let sql = '';
  
  sql += `-- ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
  sql += `-- TABLES DE JONCTION MANY-TO-MANY\n`;
  sql += `-- ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
  
  const createdJunctions = new Set();
  
  for (const rel of relations) {
    // Nom de la junction (ordre alphab√©tique pour √©viter doublons)
    const tables = [rel.sourceTable, rel.targetTable].sort();
    const junctionName = `${tables[0]}_${tables[1]}`;
    
    // Skip si d√©j√† cr√©√©e
    if (createdJunctions.has(junctionName)) continue;
    createdJunctions.add(junctionName);
    
    sql += `-- Junction: ${rel.sourceTable} <-> ${rel.targetTable}\n`;
    sql += `DROP TABLE IF EXISTS ${CONFIG.schema}.${junctionName} CASCADE;\n\n`;
    
    sql += `CREATE TABLE ${CONFIG.schema}.${junctionName} (\n`;
    sql += `  ${tables[0]}_id UUID NOT NULL,\n`;
    sql += `  ${tables[1]}_id UUID NOT NULL,\n`;
    sql += `  created_at TIMESTAMPTZ DEFAULT NOW(),\n`;
    sql += `  PRIMARY KEY (${tables[0]}_id, ${tables[1]}_id),\n`;
    sql += `  FOREIGN KEY (${tables[0]}_id) REFERENCES ${CONFIG.schema}.${tables[0]}(id) ON DELETE CASCADE,\n`;
    sql += `  FOREIGN KEY (${tables[1]}_id) REFERENCES ${CONFIG.schema}.${tables[1]}(id) ON DELETE CASCADE\n`;
    sql += `);\n\n`;
    
    // Index pour performance
    sql += `CREATE INDEX idx_${junctionName}_${tables[0]} ON ${CONFIG.schema}.${junctionName}(${tables[0]}_id);\n`;
    sql += `CREATE INDEX idx_${junctionName}_${tables[1]} ON ${CONFIG.schema}.${junctionName}(${tables[1]}_id);\n\n`;
    
    sql += `COMMENT ON TABLE ${CONFIG.schema}.${junctionName} IS 'Many-to-many: ${rel.sourceDbName} <-> ${rel.targetTable}';\n\n`;
  }
  
  return sql;
}

function generateRelationInserts(relations, databases) {
  let sql = '';
  
  sql += `-- ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
  sql += `-- POPULATION DES RELATIONS\n`;
  sql += `-- ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
  
  for (const rel of relations) {
    if (!rel.hasData) continue;
    
    const sourceDb = databases.find(db => db.sqlName === rel.sourceTable);
    if (!sourceDb) continue;
    
    const targetDb = databases.find(db => db.sqlName === rel.targetTable);
    if (!targetDb) continue;
    
    const tables = [rel.sourceTable, rel.targetTable].sort();
    const junctionName = `${tables[0]}_${tables[1]}`;
    
    sql += `-- Relation: ${rel.sourceTable}.${rel.sourceColumn} ‚Üí ${rel.targetTable}\n`;
    
    // ‚úÖ NOUVEAU : Cr√©er un Set des IDs valides pour validation rapide
    const validSourceIds = new Set(sourceDb.rows.map(r => r['Id']).filter(Boolean));
    const validTargetIds = new Set(targetDb.rows.map(r => r['Id']).filter(Boolean));
    
    const links = [];
    let skippedInvalidSource = 0;
    let skippedInvalidTarget = 0;
    let skippedNotFound = 0;
    
    // Pour chaque ligne source
    for (const sourceRow of sourceDb.rows) {
      const sourceId = sourceRow['Id'];
      if (!sourceId) continue;
      
      // ‚úÖ V√©rifier que le source ID existe vraiment
      if (!validSourceIds.has(sourceId)) {
        skippedInvalidSource++;
        continue;
      }
      
      const relationValue = sourceRow[rel.originalColumn];
      if (!relationValue) continue;
      
      const targetNames = parseRelationList(relationValue);
      
      // Pour chaque nom cible, trouver l'ID correspondant
      for (const targetName of targetNames) {
        const targetRow = targetDb.rows.find(row => {
          const name = row['Name'] || row['name'];
          return name && name.trim().toLowerCase() === targetName.toLowerCase();
        });
        
        if (!targetRow || !targetRow['Id']) {
          skippedNotFound++;
          continue;
        }
        
        // ‚úÖ V√©rifier que le target ID existe vraiment
        if (!validTargetIds.has(targetRow['Id'])) {
          skippedInvalidTarget++;
          continue;
        }
        
        // ‚úÖ V√©rifier les doublons
        const linkKey = `${sourceId}:${targetRow['Id']}`;
        if (!links.some(l => `${l.sourceId}:${l.targetId}` === linkKey)) {
          links.push({
            sourceId,
            targetId: targetRow['Id']
          });
        }
      }
    }
    
    if (links.length === 0) {
      sql += `-- Aucun lien valide trouv√©`;
      if (skippedInvalidSource > 0) sql += ` (${skippedInvalidSource} source IDs invalides)`;
      if (skippedInvalidTarget > 0) sql += ` (${skippedInvalidTarget} target IDs invalides)`;
      if (skippedNotFound > 0) sql += ` (${skippedNotFound} non trouv√©s)`;
      sql += `\n\n`;
      continue;
    }
    
    // ‚úÖ NOUVEAU : G√©n√©rer INSERT SELECT au lieu de INSERT VALUES
    // Cela v√©rifie l'existence des IDs directement dans la base de donn√©es
    sql += `-- Ins√©rer seulement si les deux IDs existent dans les tables\n`;
    sql += `INSERT INTO ${CONFIG.schema}.${junctionName} (${tables[0]}_id, ${tables[1]}_id)\n`;
    sql += `SELECT * FROM (VALUES\n`;
    
    const values = links.map((link, idx) => {
      const isLast = idx === links.length - 1;
      return `  ('${link.sourceId}'::UUID, '${link.targetId}'::UUID)${isLast ? '' : ','}`;
    });
    
    sql += values.join('\n');
    sql += `\n) AS candidate_links(${tables[0]}_id, ${tables[1]}_id)\n`;
    sql += `WHERE EXISTS (\n`;
    sql += `  SELECT 1 FROM ${CONFIG.schema}.${tables[0]} WHERE id = candidate_links.${tables[0]}_id\n`;
    sql += `)\n`;
    sql += `AND EXISTS (\n`;
    sql += `  SELECT 1 FROM ${CONFIG.schema}.${tables[1]} WHERE id = candidate_links.${tables[1]}_id\n`;
    sql += `)\n`;
    sql += `ON CONFLICT (${tables[0]}_id, ${tables[1]}_id) DO NOTHING;\n\n`;
    
    let logMsg = `  ‚úì ${rel.sourceColumn}: ${links.length} liens candidats`;
    if (skippedInvalidSource > 0 || skippedInvalidTarget > 0 || skippedNotFound > 0) {
      logMsg += ` (skipped in CSV: `;
      const skips = [];
      if (skippedInvalidSource > 0) skips.push(`${skippedInvalidSource} src`);
      if (skippedInvalidTarget > 0) skips.push(`${skippedInvalidTarget} tgt`);
      if (skippedNotFound > 0) skips.push(`${skippedNotFound} notfound`);
      logMsg += skips.join(', ') + ')';
    }
    console.log(logMsg);
  }
  
  return sql;
}

// ============================================
// MAIN
// ============================================

function main() {
  console.log('‚îÅ'.repeat(80));
  console.log('üîó RELATION BUILDER - Cr√©ation des tables de jonction');
  console.log('‚îÅ'.repeat(80));
  console.log(`üìÇ Source: ${CONFIG.importantDir}`);
  console.log(`üìÑ Output: ${CONFIG.outputSQL}`);
  console.log(`üóÇÔ∏è  Sch√©ma: ${CONFIG.schema}`);
  console.log('‚îÅ'.repeat(80));
  
  // 1. Charger tous les CSV
  const databases = [];
  const folders = fs.readdirSync(CONFIG.importantDir)
    .filter(name => {
      const fullPath = path.join(CONFIG.importantDir, name);
      return fs.statSync(fullPath).isDirectory();
    });
  
  for (const folder of folders) {
    const folderPath = path.join(CONFIG.importantDir, folder);
    const files = fs.readdirSync(folderPath);
    const csvFile = files.find(f => f.endsWith('.csv'));
    
    if (!csvFile) continue;
    
    const csvPath = path.join(folderPath, csvFile);
    const { headers, rows } = parseCSV(csvPath);
    
    if (headers.length === 0 || rows.length === 0) continue;
    
    databases.push({
      name: folder,
      sqlName: sanitizeName(folder),
      headers,
      rows,
      csvPath
    });
  }
  
  console.log(`\nüìä ${databases.length} tables charg√©es\n`);
  
  // 2. Analyser les relations
  const relations = analyzeRelations(databases);
  
  if (relations.length === 0) {
    console.log('‚ö†Ô∏è  Aucune relation d√©tect√©e !');
    process.exit(0);
  }
  
  // 3. G√©n√©rer le SQL
  console.log('‚îÅ'.repeat(80));
  console.log('üìù G√©n√©ration du SQL...\n');
  
  let sql = '';
  
  // Header
  sql += `-- ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
  sql += `-- RELATIONS MANY-TO-MANY - Fibery ‚Üí Supabase\n`;
  sql += `-- G√©n√©r√© le: ${new Date().toISOString()}\n`;
  sql += `-- Relations: ${relations.length}\n`;
  sql += `-- ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
  sql += `SET search_path TO ${CONFIG.schema}, public;\n\n`;
  
  // Tables de jonction
  sql += generateJunctionTables(relations);
  
  // Population des relations
  sql += generateRelationInserts(relations, databases);
  
  // Footer
  sql += `-- ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
  sql += `-- FIN DES RELATIONS\n`;
  sql += `-- ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
  sql += `RESET search_path;\n`;
  
  // Sauvegarder
  fs.writeFileSync(CONFIG.outputSQL, sql, 'utf8');
  
  const fileSize = (fs.statSync(CONFIG.outputSQL).size / 1024).toFixed(1);
  
  console.log('\n‚îÅ'.repeat(80));
  console.log('‚úÖ RELATIONS SQL G√âN√âR√âES !');
  console.log('‚îÅ'.repeat(80));
  console.log(`üìÑ Fichier: ${CONFIG.outputSQL}`);
  console.log(`üìä Taille: ${fileSize} KB`);
  console.log(`\nüöÄ PROCHAINES √âTAPES:`);
  console.log(`  1. Ex√©cutez d'abord migration-complete.sql dans Supabase`);
  console.log(`  2. Puis ex√©cutez ${CONFIG.outputSQL}`);
  console.log(`  3. Vos relations seront op√©rationnelles !`);
  console.log('‚îÅ'.repeat(80));
}

try {
  main();
} catch (error) {
  console.error('\n‚ùå ERREUR:', error.message);
  console.error(error.stack);
  process.exit(1);
}